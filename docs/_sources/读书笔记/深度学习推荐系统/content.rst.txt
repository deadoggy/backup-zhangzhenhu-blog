##########################################
《深度学习推荐系统》读书笔记
##########################################



重点
#######################################


.. topic:: 推荐系统中，比模型更重要的有哪些？
    不存在包治百病灵丹妙药（算法模型），每个模型都有它自己的使用场景。对于经验丰富的工程师，应该从技术中心跳出来。

    1. 站在用户的角度，深刻体验他们的想法，发现他们的习惯和偏好，然后再制定响应的解决方案，并用数据和工具去验证它、模拟它。
       总的来说，要深入了解你的场景和用户，再去制定相应的技术方案。
    2. 设定"合理"的评价指标和优化目标。战略目标发生偏差，一切都白扯。以短视频为例；
       如果仅以点击率为目标，推荐系统会倾向于"标题党"。
       如果仅以播放时长为目标，推荐系统会倾向于"长视频"。
    3. 构建一个复杂的推荐系统，并不是一个单纯的技术问题，通常需要多个团队、部门通力合作才能达成。



.. important:: 探索与利用

    推荐系统中不能一味地使用历史数据进行推荐，需要主动去试探用户新的兴趣点，主动推荐新的物品，发掘有潜力的优质商品。
    给用户推荐的机会是有限的，如何权衡用户喜欢的内容和探索新兴趣这两件事，就是 "探索与利用" 试图解决的问题。





冷启动
#######################################


根据数据匮乏情况，分三种


1. 用户冷启动。新用户刚注册缺乏历史行为数据。
2. 物品冷启动。新物品加入缺少交互记录数据。
3. 系统冷启动。新系统构建初期，缺乏所有的历史数据。



主流的冷启动解决策略可以归为三类：

1. 基于规则的冷启动。 基于业务或者经验制定一些推荐规则。
   1) 对于新用户，可以推荐热门、最近流行、高评分等等。
   2) 对于新商品，可以主动增加其曝光，尽快积累数据。
2. 基于用户和物品的基本属性。
   新用户注册，缺失的是用户交互数据，但是可以尽量获得用户的一些基本属性，比如用户年龄、性别、注册地、IP等等，物品的各类属性等等。
   此时可以：
   1) 根据这些基本属性制定一个决策规则树，制定更细致的推荐规则。
   2) 仅用基本属性训练一个简单模型。
   3) 相似用户/物品做特征迁移。可以根据基本属性计算新实体的相似实体（或者聚类），然后把相似实体的特征（特征期望值）迁移到新实体。
3. 迁移学习。区别与第2条，这里主要针对系统冷启动。可以A领域的数据或者模型用到B领域的冷启动，随着数据的增加，增量更新模型。


探索与利用
#######################################


解决 "探索与利用" 问题的主要方法：

1. 传统的方法。仅基于物品信息，不考虑用户、上下文等信息，非个性化的。
2. 个性化的方法。考虑用户和上下文信息，个性化的方法。
3. 基于模型的方法。和推荐模型结合到一起，通过改变现有推荐模型的结构来解决。


"探索与利用" 机制在推荐系统中的应用

1. 物品冷启动。
2. 发掘用户新兴趣。
3. 增加结果多样性。

召回层的主要策略
#######################################


召回解决的核心问题是：权衡计算速度和召回率。

为了权衡计算速度和召回率，工业界主流的做法是采用多个简单策略叠加的"多路召回策略"。


常见方法：

1. 协同过滤
2. 基于单一特征（比如兴趣标签）
3. 预处理好的。比如热门、最近流行、朋友喜欢。
4. 基于知识图谱的。
5. 基于 Embedding 的方法。


.. topic:: Embedding 的优势

    1. 在生成embedding时，可以引入"兴趣标签"、"热门" 等附加信息，相当于考虑的多路召回的多种策略。
    2. embedding 的评分是连续的。原来多路召回中不同召回策略产生的打分值不可以比较，而 embedding 间的相似度可以作为唯一的评判标准，
       可以方便控制召回集合的大小。
    3. 生成 embedding 的方法多种多样，可以做更细致的优化。


协同过滤 & Embedding 向量
#######################################



原始的协同过滤：

1. 构建用户和物品的共现（评分）矩阵
2. UserCF：依据相似用户填充缺失值。
3. ItemCF: 依据相似物品填充缺失值。


后来提出矩阵分解的方法来填充缺失值，矩阵分解会得到两个子矩阵，分别是用户向量矩阵和物品向量矩阵。

矩阵分解的算法有：

1. svd
2. 奇异值分解（要求仿真，显然不合适）


自此演进出了 Embedding 向量的模式，经典模式为：

1. 想办法得到用户 Embedding 向量 和 物品 Embedding 向量。
2. 用户 Embedding 向量 和 物品 Embedding 向量做內积得到评分值。


后续发展就是围绕着改进上述两个环节：

1. 针对 Embedding 向量的改进
2. 针对內积环节的改进（內积表达力不足）



- AutoRec 模型，自编码器，单隐层。
  输入层：评分矩阵的向量（行向量或列向量），隐层：全连接层，输出层：向量。目标函数：输入和输出的平方误差。
  输出向量就是对缺失值填充后的结果。

- NeuralCF：对內积的改进。
  输入层：用户 Embedding 向量 和 物品 Embedding 向量
  隐藏层：前馈网络
  输出层：评分
  目标函数：平方误差








