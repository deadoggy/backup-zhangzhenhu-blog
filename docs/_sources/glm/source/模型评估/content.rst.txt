########################################################
模型评估
########################################################







当我们训练好一个模型后，我们需要知道这个模型的"好坏"。
要评价一个模型的好坏，就需要找到合理的度量方法，
模型好坏的度量方法有很多很多，
但并不存在一个完美的度量方法能够适用于所有的场景、数据和模型。
通常我们需要依据场景、数据、模型来选择合适度量方法。
虽然度量方法很多，但我们可以根据度量目标的不同来对这些度量方法进行简单的归类和划分。

- 参数估计量的方差。
- 拟合值和观测值之间的差异。
- 每个协变量




拟合优度
#################################################

拟合优度(goodness of fit,GOF)，表示的模型输出的拟合值 (fitted value)
和实际观测值之间的差异程度，目前存在多种差异度量指标，
比如大家熟知的平方误差(损失)、似然值等都是GOF的度量指标。
通常参数估计的过程就是极值化某种拟合优度的指标的过程，
在GLM中一般是采用最大(对数)似然法估计模型参数。

一个模型拟合数据的过程，可以看做是用模型的输出拟合值(fitted value) :math:`\hat{\mu}`
去替换数据的观测值(observed) :math:`y`
，这个模型拥有较少的参数。
通常模型的拟合值 :math:`\hat{\mu}`
并不会和观测值 :math:`y` 完全相等，
接下来的问题就是两者的差异有多大。
较小的差值说明模型的拟合效果好，
反之，较大的差值说明模型拟合效果差。
模型对数据拟合效果的评估通常称为拟合优度(goodness of fit,GOF)
，``GOF`` 度量观察值 :math:`y` 与该模型拟合值 :math:`\hat{\mu}` 之间的差异。



嵌套模型
=====================================

.. glossary::
    嵌套模型(nested model)
        两个统计模型(statistical model)，如果对其中的一个模型的参数施加约束就能得到一个模型，
        则这两个模型是嵌套的(nested)。

假如我们用相同的数据拟合两个GLM，Model 1, Model 2。其中，当限制
Model 2 中部分参数为零之后会变成 Model 1 时，我们说Model 1 是 Model 2 的嵌套模型。

.. topic:: 例1：嵌套模型示例I

    模型1的线性预测器(linear predictor)方程为:

    .. math::
        \eta = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_3 + \beta_3 x_4

    模型2和模型1相比，响应变量使用相同的指数族分布，并且使用相同的连接函数(link function)和尺度参数(scale parameter, :math:`\phi` )，
    但是其线性预测器的方程为：

    .. math::
         \eta = \beta_0 + \beta_1 x_1


    此时，我们就说模型2是模型的1的嵌套模型(nested model)，因为通过对模型1的参数施加约束 :math:`\beta_2=\beta_3=\beta_4=0`
    就得到了模型2。




.. topic:: 例2：嵌套模型示例II

    模型1的线性预测器(linear predictor)方程为:

    .. math::
        \eta = \beta_0 + \beta_1 x_1 + \beta_2 x_1^2

    模型2和模型1相比，响应变量使用相同的指数族分布，并且使用相同的连接函数(link function)和尺度参数(scale parameter, :math:`\phi` )，
    但是其线性预测器的方程为：

    .. math::
         \eta = \beta_0 + \beta_1 x_1


    此时，仍然认为模型2是模型的1的嵌套模型(nested model)，因为通过对模型1的参数施加约束 :math:`\beta_2=0`
    ，模型1就变成了模型2。



我们知道，模型的参数越多对数据的拟合程度就越好，极端情况下，模型参数的数量和样本的数量相同，
这时就相当于对每条样本都有一个独立的参数(模型)去拟合它，理论上可以完美拟合所有的样本。
我们把这样的模型成为之饱和模型(saturated model)，也可以称为
完整模型(full model)或者最大模型(maximal model)。
饱和模型虽然能完美拟合数据集，但它并没有从数据集中学习出任何的统计信息(统计规律)，所不具备泛化能力，
俗称过拟合(over-fitted)。
通过为饱和模型中的参数添加约束，比如令一些参数值为0，相当于去掉了一个参数，这样就得到了简化的模型。
简化模型对数据集拟合度下降了，但是其泛化能力会得到提升，
更少的参数数量可以得到更大的泛化能力。
但是参数数量变少，会降低拟合程度，参数数量越少拟合度就越差，所以也不是参数越少越好。


我们把完美拟合数据的模型称之为饱和模型(saturated model)，
饱和模型为每一条样本定义一个参数，有多少条样本就有多少个参数，
这样就能完美拟合所有的样本。
同样的道理，我们可以定义一个"最差"的模型，
参数越多的模型拟合度越好，参数越少拟合度越差，
我们定义只有一个截距参数的模型为"最差"的模型，通常称为零模型(null model)。
零模型的线性预测器只有截距( :math:`\beta_0` )部分，而没有预测变量。

.. math::
    \eta = \beta_0

:numref:`fg_me_saturated_0010` 展示了饱和模型(saturated model)、拟合的逻辑回归模型(logistic regression)、空模型(null model)
三种模型拟合效果的对比情况。饱和模型可以拟合所有的点，而空模型对所有样本只能输出一个固定值。

.. _fg_me_saturated_0010:

.. figure:: pictures/me_saturated_0010.png
    :scale: 40 %
    :align: center

    饱和模型(saturated model)、拟合的逻辑回归模型(logistic regression)、空模型(null model)


对数似然比(Likelihood ratio)
========================================================


我们知道似然(Likelihood)其实就是样本的联合概率，似然值越大说明模型对样本的拟合程度越好，
因此我们可以通过对比两个模型的似然值来比较两个模型的好坏。
我们把参数少的模型称为简单模型，用符号 :math:`s` 表示，:math:`L_s` 表示模型 :math:`s` 的似然；
另一个参数较多的模型称为复杂模型，用符号 :math:`g` 表示，:math:`L_g` 表示模型 :math:`g` 的似然。


在统计学中，可以通过比较两个嵌套模型的似然值来评判哪个模型对数据拟合的更好。
似然比(likelihood-ratio,LR)就是用来对比两个嵌套模型对于同一份数据集的拟合程度，
LR的计算公式如下：

.. math::

    LR = -2  \left ( \frac{L_s  }{L_g} \right )

其中 :math:`L_g` 为复杂模型似然值，:math:`L_s` 为简单模型似然值。
从公式可以看出，似然比就是两个模型的似然值比值。
通常并不直接使用上述似然值的比值，而是会加上一个对数，变成对数似然比。

.. math::
    LLR = -2 \ln \left ( \frac{L_s  }{L_g} \right ) = 2 \ln \frac{L_g}{L_s} = 2 (\ln L_g-\ln L_s)

加上对数操作后，就变成了两个模型对数似然值的差值，使得计算更加方便。
似然(likelihood)，实际上也可以翻译为可能性，表示的是样本发生的概率，显然似然值越大的模型对数据的拟合也就越好。
似然比就是直接比较两个模型的似然值大小。
但是并不是任意两个模型都可以应用似然比去比较，只有在特定条件下似然比才有意义。

1. 两个模型采用同一份数据集，样本的数量和特征都是相同的。这很好理解，不同数据集似然值自然是不同的，没有比较的意义。
2. 两个模型是嵌套关系(nested)。


对于两个嵌套模型，其差别就是参数数据量不同。
在 ``GLM`` 中，就是协变量参数向量 :math:`\beta` 的长度不同，
简单模型的参数向量 :math:`\beta_s` 是复杂模型参数向量 :math:`\beta_g` 的子集，
把 :math:`\beta_g` 中部分元素设置为 :math:`0` 就得到了 :math:`\beta_s` 。
我们知道，在拟合效果一样的前提下，参数数量越少的模型越"好"，我们更期望于得到一个参数少的模型，
也就是尽量得到一个简单模型。然而理论上，参数越多的模型对数据拟合就越好，
复杂模型的对数似然值一定是大于等于简单模型的，因此一定有 :math:`LLR \ge 0` 。
理论上当 :math:`LLR=0` 时，说明两个模型的拟合效果完全一样。
然而实际上几乎是不可能实现的，对数似然比的值基本上都是一个大于零的值。

``LLR`` 的值什么范围的值意味着两个模型拟合程度接近呢？
这就需要找到一个判断的方法和标准。
事实上，对数似然比也是一个统计量，称为似然比统计量(Likelihood-ratio statistic)，
并且其渐进服从卡方分布，其自由度(期望)等于两个嵌套模型的参数数量之差。
既然是一个统计量，就表示LLR的值是一个随机值，
因此直接使用 ``LLR`` 值进行模型好坏的判断是不可靠的。
可以通过假设检验的方法，利用似然比统计量对两个模型进行对比检验，
这种检验方法称为似然比检验(likelihood-ratio test,LRT)
有时也被称为似然比卡方检验(likelihood-ratio chi-squared test,LRCT)。
在统计学中，似然比检验，
是用来比较两个嵌套模型的拟合优度(goodness of fit,GOF)的方法。
似然比检验是基于最大似然估计的统计模型中应用广泛的一种模型对比方法，
有关假设检验的相关内容下一章在详细讨论。


偏差(deviance)
========================================================


上一节我们介绍了似然比统计量，似然比检验是常用的一种嵌套模型比较的方法。
似然比检验是对比两个模型的，不是用来衡量单个模型的。
本节我们介绍似然比统计量的一个衍生量-偏差统计量(deviance,statistic)，
偏差统计量本质上就是似然比统计量，但它可以用来度量单个模型的拟合效果。


在开发一个模型时，我们希望模型的预测值 :math:`\hat{y}` 尽可能的接近数据的真实值 :math:`y`
，对于一个规模为N的观测值样本，我们可以考虑参数数量在 :math:`[1,N]` 之间的候选模型。
最简单的模型是只有一个参数的模型，但它对所有的样本的预测值都是一样的，缺乏拟合能力，
只有一个参数的模型称为空模型(null model)。
最复杂的模型是含有 :math:`N` 个参数的模型，它可以完美拟合所有样本，但是它缺乏泛化能力，
这样的模型称为饱和模型(saturated model)。
在实际应用中，空模型过于简单，而饱和模型又缺乏数据的抽象进而没有泛化能力。
虽然饱和模型不能直接拿来用，但是其却可以作为模型拟合能力评价指标的基准。


我们把训练出的模型模型称为拟合模型(fitted model)，用符号 :math:`L_t` 表示它的似然值，
同理用符号 :math:`L_f` 表示对应饱和模型的似然值。
则二者之间的对数似然比统计量为：

.. math::
    :label: eq_me_051

    D  = 2(\ln L_f - \ln L_t)

在 ``GLM`` 中，我们把饱和模型和拟合模型之间的似然比统计量定义为 **偏差(deviance)统计量**，
常用符号 :math:`D` 表示。
严格来说，偏差统计量就是似然比统计量的一个特例，其比较的是饱和模型和训练出的模型之间的拟合度。
饱和模型是完美拟合数据的模型，其对数似然值是理论最大值，代表了模型拟合度的最高值，
可以作为训练模型拟合度度量的一个"参考线"，
训练模型的对数似然值"越接近"饱和模型的对数似然值说明训练模型拟合度越好。


模型的预测值 :math:`\hat{y}_i` 就是分布 :math:`p(y_i|x_i)` 的期望值
:math:`\mathbb{E}[p(y_i|x_i)]=\hat{\mu}_i` ，即 :math:`\hat{y}_i=\hat{\mu}_i` 。
所以这里我们用 :math:`\hat{\mu}_i` 表示模型的预测值。
现在回顾一下GLM中的指数族概率分布函数的形式 :eq:`eq_me_052`，

.. math::
    :label: eq_me_052

    p(y_i|\theta_i) = \exp \left \{\frac{\theta_i y_i - b(\theta_i)}{a(\phi)} + c(y_i,\phi) \right \}

其中自然参数 :math:`\theta_i` 可以表示成期望 :math:`\mu_i` 的函数，
所以对于拟合模型自然参数 :math:`\theta_i` 可以写成 :math:`\theta_i(\hat{\mu}_i)`
，拟合模型的对数似然函数可以写成：



.. math::
    :label: eq_34_51

    \ln L_t =   \sum_{i=1}^N \frac{y_i \theta(\hat{\mu}_i) -b(\theta(\hat{\mu}_i))}{a(\phi)}
    + \sum_{i=1}^N  c(y_i;\phi)


至此，我们把拟合模型的似然函数表示成了关于 :math:`\hat{\mu}` 的函数。
同理，对于饱和模型(saturated model)，模型是完美拟合数据的，所以其预测值是精确等于样本的观测值的，
即 :math:`\hat{y}_i=y_i` ，换句话说，
对于饱和模型，满足 :math:`\hat{y}_i=\hat{\mu}_i=y_i`
。因此，饱和模型的对数似然函数为：


.. math::
    :label: eq_34_52

    \ln L_f =   \sum_{i=1}^N \frac{y_i \theta(y_i) -b(\theta(y_i))}{a(\phi)}
    + \sum_{i=1}^N  c(y_i;\phi)



注意在 ``GLM`` 中，分散参数 :math:`\phi` 与模型的期望 :math:`\mu` 无关，
模型关注的参数是协变量参数 :math:`\beta` ，
而分散参数 :math:`\phi` 是冗余参数，并且与样本无关。
因此分散参数没有下标 :math:`i`，
并且无论是饱和模型还是拟合模型，分散参数是相同的值。

现在把 :eq:`eq_34_51` 和 :eq:`eq_34_52` 代入到偏差统计量 :eq:`eq_me_051`
，两个对数似然函数中的项 :math:`\sum_{i=1}^N  c(y_i;\phi)` 是相等的，可以抵消掉。



.. math::
    :label: eq_34_53

    D = \frac{2}{a(\phi)} \sum_{i=1}^N  [
    y_i \{ \theta(y_i) - \theta(\hat{\mu}_i) \} - b\{\theta(y_i)\} + b\{\theta(\hat{\mu}_i)\} ]



在 ``GLM`` 的应用中，多数情况下 :math:`a(\phi)=\phi` ,
但有时会假设 :math:`a(\phi)=\phi/w_i`
此时 :math:`w_i` 表示样本权重值，意味着每条观测样本都可以有不同的权重值，
权重值 :math:`w_i` 是已知的。
偏差统计量 :math:`D` 就变成：

.. math::

    D = \frac{2w_i}{\phi} \sum_{i=1}^N  [
    y_i \{ \theta(y_i) - \theta(\hat{\mu}_i) \} - b\{\theta(y_i)\} + b\{\theta(\hat{\mu}_i)\} ]


权重 :math:`w_i` 并不是必要的，只有在实际使用场景中需要为每条观测样本设置不同权重时才需要，并且其值是事先已知的。
因此在很多有关偏差得资料中并没有提及，在本书后续的讨论中，若无特别说明，默认也省略掉权重，
并且假设 :math:`a(\phi)=\phi` ，则偏差统计量的计算公式为


.. math::

    D = \frac{2}{\phi} \sum_{i=1}^N  [
    y_i \{ \theta(y_i) - \theta(\hat{\mu}_i) \} - b\{\theta(y_i)\} + b\{\theta(\hat{\mu}_i)\} ]




偏差统计量的计算依赖分散参数 :math:`\phi` ，
在 ``GLM`` 的众多分布中，离散分布都是不存在分散参数的，相当于 :math:`\phi=1` ；
连续值分布虽然存在分散参数 :math:`\phi` ，但在使用过程中一般都假设分散参数 :math:`\phi`
是已知的常量，比如高斯模型通常假设 :math:`\phi=1` 。
鉴于此，早期很多资料默认把分散参数 :math:`\phi` 从偏差统计量的计算中去掉了(相当于 :math:`\phi=1`)，
变成了


.. math::

    D = 2 \sum_{i=1}^N  [
    y_i \{ \theta(y_i) - \theta(\hat{\mu}_i) \} - b\{\theta(y_i)\} + b\{\theta(\hat{\mu}_i)\} ]


这造成了很多混淆，为了区分二者，把带有分散参数的称为尺度化偏差(scaled deviance)，用符号 :math:`D^*` 表示;
不带分散参数的称为偏差，用符号 :math:`D` 表示。当 :math:`\phi=1` 时，二者是等价的，它们的关系是

.. math::

    D = \phi D^*
    \quad \text{或者} \quad
    D^* = \frac{D}{\phi}

为了表述清晰统一，本书默认使用完整的带有分散参数的标准公式，并统一使用名称"偏差(deviance)" 和符号 :math:`D` 表示，
即偏差统计量(deviance statistic)，:math:`D` ，定义为

.. math::

    D &= 2 \{ \ell(y;y)-\ell(\hat{\mu};y)\}

    &= \frac{2}{a(\phi)} \sum_{i=1}^N  [
    y_i \{ \theta(y_i) - \theta(\hat{\mu}_i) \} - b\{\theta(y_i)\} + b\{\theta(\hat{\mu}_i)\} ]

    &= \frac{2}{\phi} \sum_{i=1}^N  [
    y_i \{ \theta(y_i) - \theta(\hat{\mu}_i) \} - b\{\theta(y_i)\} + b\{\theta(\hat{\mu}_i)\} ]



偏差统计量是定义在整个观测样本上的，
单条样本的偏差(deviance)通常称为单位偏差（unit deviance），习惯上用符号 :math:`d_i(y_i,\hat{\mu}_i)` 表示，
整个观测样本的偏差就是所有个体单位偏差的求和，:math:`D=\sum_{i=1}^N d_i(y_i,\hat{\mu}_i)`。
。


偏差统计量就是对数似然比统计量的一个特例，比较的是拟合模型(我们训练出来的模型)和饱和模型的拟合度，
饱和模型的对数似然值是可以直接计算出的，并且是当前观测样本集的似然值上限，
因此偏差统计量可以用度量模型的拟合优度。
当然由于偏差统计量是对数似然比的一个特例，其也继承了对数似然比统计量的特性，比如偏差统计量的渐近分布也是卡方分布。
同样偏差值本身也不能直接用来判断模型的好坏，需要借助假设检验的手段才行，在下一章会详细讨论。


**最小偏差与最大似然**

偏差统计量是饱和模型的对数似然值和拟合模型对数似然值差值的2倍，
在确定性观测样本集合模型下，饱和模型的对数似然值是一个常量，


.. math::

     D = 2 [ \underbrace{\ell(y;y)}_{\text{常量}}-\ell(\hat{\mu};y) ]

在进行参数估计时，最小化偏差就相当于最大化拟合模型的对数似然，
因此 **参数的最大化似然估计和最小化偏差估计是等价的**。


**偏差和最小二乘法的关系**

对于标准连接的高斯分布模型，也就是传统的线性回归模型，
有 :math:`\theta=\eta=\mu,b(\theta)=\mu^2/2,a(\phi)=\sigma^2`
，因此其偏差为：

.. math::

    D &= 2  \sum_{i=1}^N  [ y_i \{ y_i - \hat{\mu}_i \} - y_i^2/2 +\hat{\mu}_i^2/2 ]

    &= 2 \sum_{i=1}^N  [ y_i^2/2  - y_i \hat{\mu}_i  +\hat{\mu}_i^2/2 ]

    &= \sum_{i=1}^N  (y_i-\hat{\mu}_i)^2


可以看到，标准连接高斯分布的偏差(deviance)和平方和损失是一致的，实际上
**偏差(deviance)可以看做是传统线性回归模型最小二乘（平方损失）在GLM中的扩展**。


.. csv-table:: 常见GLM模型的偏差（采用标准连接函数，并且 :math:`\phi=1`）
    :header: "分布","偏差(deviance)"

    "Gaussian(Normal)",   ":math:`\sum_{i=1}^N (y_i-\hat{\mu}_i)^2`"
    "Poisson",   ":math:`2 \sum_{i=1}^N \{ y_i\ln(y_i/\hat{\mu}_i) -(y_i-\hat{\mu}_i) \}`"
    "Binomial",   ":math:`2\sum_{i=1}^N\{ y_i\ln(y_i/\hat{u}_i)+(m-y_i)\ln[(m-y_i)/(m-\hat{\mu}_i)] \}`"
    "Gamma",   ":math:`2\sum_{i=1}^N\{-\ln(y_i/\hat{\mu}_i)+(y_i-\hat{\mu}_i)/\hat{\mu}_i\}`"
    "Inverse Gaussian",   ":math:`\sum_{n=1}^N\{(y_i-\hat{\mu}_i)^2/(\hat{\mu}_i^2y_i)\}`"




**偏差统计量的抽样分布**

偏差(deviance)是对数似然比统计量的一个特例，
因此也是一个统计量，并且其渐近分布也是卡方分布。
偏差统计量 :math:`D` 是渐近服从卡方分布 :math:`\chi^2` 的。

.. math::

    \begin{align}
    D \sim \chi^2(N-p)
    \end{align}

符号 :math:`\chi^2(N-p)` 的意思是自由度为 :math:`N-p` 的卡方分布，
卡方分布的自由度就是其期望参数，自由度为 :math:`N-p` ，也就意味着期望是 :math:`N-p`。
其中 :math:`N` 是饱和模型的参数数量，同时也是观测样本的数量。
:math:`p` 是拟合模型的参数数量(包含截距参数)，

注意，所谓渐近分布是指随着样本数量增加，变量逐渐服从某个概率分布。
理论当 :math:`N` 无限大时，变量才精确服从这个概率分布。
实际上经验来看，当样本数量在几百个以上时误差已经基本可以忽略了，当然具体地还要看实际情况如何。
在 ``GLM`` 中有一个特殊的情况是，标准连接的高斯模型其偏差是精确服从卡方分布的，而不是渐近的。


**两个嵌套的模型的偏差统计量的差值，就相当于这两个嵌套模型的对数似然比统计量**。
当两个嵌套模型的偏差统计相减时，其中饱和模型的项就会抵消掉，最后就等于两个模型的对数似然值做差值，
也就变成了对数似然比统计量。
偏差统计量是 ``GLM`` 中最常用的统计量，有关如何利用偏差统计量进行模型检验的方法下章详细介绍。



决定系数 :math:`R^2`
======================================

在传统线性回归模型（也叫 ``OLS``，最小二乘回归，也是响应变量 :math:`Y` 是高斯分布的 ``GLM``）中，
常用的一种度量拟合优度的方法是 :math:`R^2`。
原始版本的 :math:`R^2` 是定义在 ``OLS`` 模型上的，在非 ``OLS`` 的模型中并不适用。
有很多学者提出了很多变种 :math:`R^2`，用在其它非 ``OLS`` 模型中，比如二分类的逻辑回归模型。
本节我们先给出在 ``OLS`` 中 :math:`R^2` 的定义，然后再给出用于 ``GLM`` 的变种版本。


线性回归中的 :math:`R^2`
-------------------------------------------------

:math:`R^2` ，也称作决定系数（coefficient of determination），
用来度量 ``OLS`` 模型对数据的拟合优度。
我们先给出 :math:`R^2` 的计算公式，然后再进行解释。

令 :math:`y_i` 表示样本的观测值，:math:`\hat{y}_i` 表示模型对样本的预测值，
:math:`\bar{y}` 表示样本的均值。
则 :math:`R^2` 的计算法方法为

.. math::
    :label: eq_me_101

    R^2 = 1 - \frac{\sum_{i=1}^N(y_i -\hat{y}_i)^2}{\sum_{i=1}^N(y_i -\bar{y}_i)^2}



我们首先看下公式中分子的部分，:math:`\sum_{i=1}^N(y_i -\hat{y}_i)^2`。
:math:`\hat{y}_i` 是模型的预测值，:math:`y_i` 是样本的真实观测值，
二者的差值 :math:`y_i -\hat{y}_i` 显然就是模型拟合误差，
分子部分显然就是残差平方和（residual sum of squares），记作 ``RSS`` 。
它是 ``OLS`` 模型的损失函数，也是优化的目标函数。
``RSS`` 越大意味着模型对数据拟合的越差，所以 ``RSS`` 越小越好，
``RSS`` 的取值范围是 :math:`[0,\infty]`，
虽然理论上最小值是 :math:`0`，:math:`0` 代表着模型能完美拟合所有观测样本，
然而实际应用中，是不可能得到 :math:`0` 的，通常是得到一个正数，
单纯看一个 ``RSS`` 值，缺乏一个参照标准，
不能直观的判断出模型的拟合能力是否已经到达极限，还有没有优化提升的空间。
:math:`R^2` 的分母 :math:`\sum_{i=1}^N(y_i -\bar{y}_i)^2`
就是 ``RSS`` 的一个上限，它能给出 ``RSS`` 一个上限参照标准。


现在我们来看下 :math:`R^2` 中分母的解释。假设我们的模型不包含任何输入变量 :math:`X`
，模型只有一个截距参数，上文已经讲过，这样的模型称为空模型（null model）。
空模型只有一个截距参数，只能学习到观测数据的均值，
空模型输出的预测值就是 :math:`\bar{y}`，
因此分母部分可以看做是空模型的残差平方和。
空模型是最简单最基本的模型，它的残差平方和就可以看做是一个最大的上限，
可以称为总平方和（total sum of squares)，记作 ``TSS``。
:eq:`eq_me_101` 可以写为

.. math::

    R^2 = 1 - \frac{RSS}{TSS}


在 ``OLS`` 中，``TSS`` 是 ``RSS`` 的一个理论上限，
这使得 :math:`\frac{RSS}{TSS}` 的取值在 :math:`[0,1]` 之间，
其实越接近 :math:`1` 表示模型的残差越大，模型拟合效果越差，
模型的拟合效果与 :math:`\frac{RSS}{TSS}` 的值是相反的，
这不符合大家的习惯，因此，我们用 :math:`1` 减去 :math:`\frac{RSS}{TSS}`。
理论上 :math:`R^2` 的取值范围是 :math:`[0,1]`，
越接近 :math:`1` 意味着模型对数据的拟合效果越好。








**方差解释**




:math:`R^2` 的另一种解释是方差，
``TSS`` 是观测样本的全部方差，
``TSS-RSS`` 就是模型对数据方差的解释（explained sum of squares），
表示模型可以解释（预测、拟合）的方差，记作 ``ESS``。


.. math::

    R^2 = 1 - \frac{RSS}{TSS}
    = \frac{TSS-RSS}{TSS} = \frac{ESS}{TSS}


:math:`R^2` 就表示在空模型的基础上增加预测（特征）变量后的模型，
对观测变量全部方差（TSS）解释的比例。
假设计算出 :math:`R^2=0.7`，
这可以看做是预测（特征）变量 :math:`X` 解释（拟合）了观测变量 :math:`Y` 的 :math:`70\%` 的方差，
剩下的 :math:`30\%` 是当前的 :math:`X` 没有解释的，没解释的部分是 ``RSS``。

用 :math:`V(y)` 表示观测样本的方差，
:math:`V(\hat{y})` 表示模型的方差，
:math:`V(\hat{\epsilon}) = V(y) - V(\hat{y})`，
:math:`R^2` 也可以定义成如下的形式。

.. math::

    R^2 = \frac{V(\hat{y})}{V(y)} = \frac{V(\hat{y})}{V(\hat{y}) + V(\hat{\epsilon})}


:math:`V(\hat{y})` 是拟合模型的方差，
:math:`V(y)` 是观测样本的方差，
:math:`V(\hat{\epsilon})` 是多出来的模型未能解释的部分。


:math:`R^2` 还有另一个理解，就是看做相关性系数的平方。
:math:`X` 与 :math:`Y` 的相关系数记作 :math:`R`，
它的平方就是 :math:`R^2`。
但是注意，:math:`R^2` 本质是度量的 :math:`\hat{Y}` 与 :math:`Y` 的残差，
严格来说，它并没有考虑 :math:`X`的，只是当 :math:`X` 与 :math:`Y` 存在线性关系时，
会影响 :math:`R^2` 的值。 :math:`X` 与 :math:`Y` 线性关系越强烈，
:math:`\hat{Y}` 与 :math:`Y` 的残差就越小；
反之，:math:`X` 与 :math:`Y` 线性关系越差，
:math:`\hat{Y}` 与 :math:`Y` 的残差就越大；
但这种关系毕竟是间接的，尽量不要使用 :math:`R^2`
去衡量 :math:`X` 与 :math:`Y` 线性关系，如果你不是很了解 :math:`R^2`，非常容易得出错误的结论。
建议仅用 :math:`R^2` 来度量模型的拟合优度。




修正的 :math:`R^2`
----------------------------------------------------------------------------------

实际上，上述版本 :math:`R^2` 存在一个小小的瑕疵。
:math:`R^2` 用来度量模型对数据的拟合优度，
然后实际上，只要添加了新的预测（特征）变量，
:math:`R^2` 的值都会增加，至少不会减少，
无论新增的这个预测变量 :math:`X` 是否和 :math:`Y` 相关，
也就是说即使新增加的 :math:`X` 和 :math:`Y` 完全不相关，
添加之后也会导致 :math:`R^2` 变大，
这里我们省略证明过程。
这就导致在多维（多个特征变量）模型中，
:math:`R^2` 的值不再可靠。
针对这种情况，提出了改进版本的 :math:`R^2`，
修正的（Adjusted）:math:`R^2`，
记作 :math:`\bar{R}^2`，
也可以记作 :math:`R^2_{adj}`。


.. math::

    \bar{R}^2 = 1 - \frac{RSS/\text{df}_{r}}{TSS/ \text{df}_{t}}

:math:`\text{df}_{r}` 是 ``RSS`` 的自由度，其值为 :math:`N-p-1`，
:math:`\text{df}_t` 是 ``TSS`` 的自由度，其值是 :math:`N-1`。
:math:`N` 是观测样本的数量，:math:`p` 是模型中特征变量 :math:`X` 数量，
注意 :math:`p` 不包含截距。
:math:`N-p-1` 与 :math:`N-1` 中的 :math:`1` 表示截距参数。



.. math::

    \bar{R}^2 = 1 - \frac{RSS}{TSS}\frac{N-1}{N-p-1}




修正版的 :math:`R^2` 会惩罚没有意义的特征，
添加了无意义的特征后，:math:`\bar{R}^2` 的值甚至会变小，
这使得 :math:`\bar{R}^2` 可以用来检验新增加的特征对模型是否有意义。
在单特征的模型中，:math:`\bar{R}^2` 与 :math:`R^2` 的效果是一样的，
在多特征的模型中，:math:`\bar{R}^2` 是更好的，
因此建议大家尽量使用 :math:`\bar{R}^2`。
:math:`\bar{R}^2` 与 :math:`R^2` 的关系为



.. math::

        \bar{R}^2 = 1 - (1-R^2)\frac{N-1}{N-p-1}




偏差版本的 :math:`R^2`
----------------------------------------------------


不管是 :math:`R^2` 还是 :math:`\bar{R}^2`
，都是定义在 ``OLS`` 模型的基础上的，
对于 ``GLM`` 中的其它模型是不适用的。
很多研究者提出了很多变种版本，
用于适配 ``GLM`` 中其它模型，
本节我们介绍其中一个基于偏差的版本。
我们知道偏差（deviance）统计量是误差平方和的扩展，
因此可以定义一个偏差版本的 :math:`R^2`。

用符号 :math:`L_0` 表示空模型(null model)的似然，并且把空模型的偏差值定义为
空偏差(null deviance)，用符号 :math:`D_0` 表示。
有些翻译把 "null deviance" 翻译成"零偏差"，
个人觉得这非常容易产生混淆，"零偏差" 看上去好像是 *偏差值为0* ，
然而这里指的是 "null model" 的偏差值，
所以我们继续沿用"空"来翻译"null"。

.. math::

    D_0 =2\phi(\ln L_f -\ln L_0)



用符号 :math:`D` 表示拟合模型的残差偏差统计量，
可以用一张图来说明 :math:`D_0` 和 :math:`D` 之间的关系。
我们拟合的模型，可以看做是在空模型的基础上增加预测变量 :math:`X_1,X_2,\dots,X_p`
得到更小的偏差(deviance)。

.. _fg_me_saturated_0012:

.. figure:: pictures/me_saturated_0012.jpg
    :scale: 50 %
    :align: center

    The residual deviance ( :math:`D` ) and the null deviance (:math:`D_0`).

可以用 :math:`D` 替代 :math:`RSS`，
:math:`D_0` 替代 :math:`TSS`，
这样就得到一个偏差版本的 :math:`R^2` 统计量。

.. math::

    R^2_{D} = 1- \frac{D}{D_0}






.. _ch_glm_gof_chi:

广义皮尔逊卡方统计量
=========================================

在 ``GLM`` 中，另一个常用的拟合度统计量是广义皮尔逊卡方统计量(generalized Pearson chi-square statistic)
，其计算公式为


.. math::
    :label: eq_glm_me_302

    \chi^2 &= \sum_{i=1}^N  \frac{(y_i-\hat{\mu}_i)^2}{a(\phi)\nu(\hat{\mu}_i)}

    &= \sum_{i=1}^N  \frac{(y_i-\hat{\mu}_i)^2}{V(\hat{\mu}_i)}

其中 :math:`V(\mu_i)=a(\phi)\nu(\hat{\mu}_i)` 表示模型的方差。
和偏差统计量类似的情况，很多资料中会省略分散函数 :math:`a(\phi)` ，
直接定义为如下形式

.. math::
    :label: eq_glm_me_303

    \chi^2 = \sum_{i=1}^N  \frac{(y_i-\hat{\mu}_i)^2}{\nu(\hat{\mu}_i)}


然而这是不准确的，非常容易产生误导，只有当 :math:`a(\phi)=1` 时，才能省略掉。
也有些资料把 :eq:`eq_glm_me_303` 称为皮尔逊卡方统计量，而把 :eq:`eq_glm_me_302` 称为尺度化(scaled)的皮尔逊卡方统计量。
为了简单清晰表达，如无特别说明，本书中默认使用 :eq:`eq_glm_me_302` 的完整定义表示皮尔逊卡方统计量。


顾名思义，皮尔逊卡方统计量的渐近分布是卡方分布，这和偏差统计量是一样的，
同样其自由度(期望)是样本数量减去模型参数数量，:math:`N-p-1` 。
偏差统计量是基于最大似然估计的，因此其再基于最大似然估计的嵌套模型比较时有很大的优势，
而皮尔逊卡方统计量胜在可解释性更强。
对于高斯模型，有 :math:`\nu(\mu)=1,a(\phi)=1` ，
其皮尔逊卡方统计量、偏差统计量以及平方损失都是等价的，并且都是精确服从卡方分布的。


平方损失，亦即残差的平方和(residual sum of squares，RSS)，是样本观测值和模型拟合值之间误差的平方和，这非常直观，易于理解。
但是对于不同场景的观测样本，其取值范围差别很大，``RSS`` 值难以直接评判大小。
皮尔斯卡方统计量在 ``RSS`` 的基础上除以模型分方差，可以看成 ``RSS`` 的归一化版本，
从误差的绝对值变成多少个标准差，有利于对其值进行直观上的大小比较。


对于分散参数 :math:`\phi` 值未知的模型和场景，可以利用皮尔逊卡方统计量得到分散参数 :math:`\phi`
的一个估计值。:math:`\chi^2` 统计量的渐近分布是卡方分布，并且其期望为 :math:`N-p-1`
，因此有

.. math::

    \mathbb{E}[\chi^2] = \mathbb{E} \left [
        \sum_{i=1}^N  \frac{(y_i-\hat{\mu}_i)^2}{a(\phi)\nu(\hat{\mu}_i)}
    \right ] = N-p-1


利用这个特点可以近似的得到 :math:`a(\phi)` 。

.. math::


    a(\phi) = \sum_{i=1}^N  \frac{(y_i-\hat{\mu}_i)^2}{(N-p-1)\nu(\hat{\mu}_i)}

当 :math:`a(\phi)=\phi` 时，分散参数的近似估计值为

.. math::


    \hat{\phi} = \sum_{i=1}^N  \frac{(y_i-\hat{\mu}_i)^2}{(N-p-1)\nu(\hat{\mu}_i)}




当 :math:`a(\phi)=\phi / w_i` 时，分散参数的近似估计值为

.. math::


    \hat{\phi} = \sum_{i=1}^N  \frac{ w_i (y_i-\hat{\mu}_i)^2}{(N-p-1)\nu(\hat{\mu}_i)}



残差分析(Residual analysis)
##########################################

在评估模型时，残差(residual)用于衡量我们的每个样本观察值与拟合值之间的差异。
一个观测值影响估计系数的程度是一种影响的度量。
``Pierce`` 和 ``Schafer（1986）`` 以及 ``Cox和Snell（1968）`` 对 ``GLM`` 中残差的各种定义提出了出色的结论。
在以下各节中，我们介绍为 ``GLM`` 提出的几种残差的定义。
但是目前的文献中，对 ``GLM`` 中各类残差的定义缺乏统一的术语，
导致容易产生混淆，因此我们尽量保留使用英文术语，以方便与其他书籍和论文进行比较。


通常残差(residual)也用符号 :math:`r` 表示，这和响应函数 :math:`r` 在符号上重复了，
所以本节在出现响应函数的地方我们用连接函数的反函数 :math:`g^{-1}` 表示。
另外残差(residual)都是定义在单条样本上的，
以下所有残差的定义中下标 :math:`i` 都表示第 :math:`i` 条样本。

Response residuals
==============================================


``Response residuals``， 也叫作 ``raw residuals``， 其定义十分简单直接，就是样本的观测值(真实值)
:math:`y_i` 和模型拟合值(预测值) :math:`\hat{y}_i` 之间的差值。

.. math::

    r_i^R = y_i -\hat{y}_i


在 ``GLM`` 中，拟合值 :math:`\hat{y}_i` 就是响应函数的输出值，并且表示响应变量的期望值
:math:`\hat{y}_i=\hat{\mu}_i=g^{-1}(\eta_i)`
。因此在GLM中，上式也可以写成：

.. math::

    r_i^R = y_i -\hat{\mu}_i


在之后的残差定义中，我们都使用 :math:`\hat{\mu}_i` 表示样本的拟合值。

Working residuals
==============================================

工作残差(working residuals)是在模型收敛时的残差，
``working response`` 和 ``linear predictor`` 之间的差值。

.. math::

    r^W_i = (y_i -\hat{\mu}_i) \frac{\partial \eta_i}{\partial \hat{\mu}_i} = (y_i -\hat{\mu}_i) g'(\hat{\mu}_i)

其中 :math:`\frac{\partial \eta}{\partial \mu}` 是连接函数的导数 :math:`g'(\mu_i)`
。这里我们回归一下IRLS算法迭代过程中 :math:`Z` 项的计算公式，
``working residuals`` 就是 :math:`Z` 的一部分。

.. math::

       Z^{(t)} = \left \{ (y-\mu)  \left ( \frac{\partial \eta}{\partial \mu} \right) + \eta^{(t)}
    \right \}_{(n\times 1 )}


Partial residuals
==============================================
``Partial residuals`` 用于评估每个预测变量(predictor)的，
并因此针对每个预测变量进行计算。
O’Hara Hines和Carter（1993）讨论了这些残差在评估模型拟合中的图形使用。


.. math::

    r^T_{ij} = r^W_{i} + x_{ij} \beta_j

上式中 :math:`r^W_{i}` 表示的是样本 :math:`i` 的 ``Working residuals``，
:math:`x_{ij} \beta_j` 仅是第 :math:`j` 维输入特征的线性预测器。
``Partial residuals`` 评估的是单一维度特征的预测器的残差。



Pearson residuals
==============================================

皮尔逊残差(Pearson residuals)是工作残差(working residuals)的重新缩放版本。
皮尔逊残差平方的总和等于皮尔逊卡平方统计量(Pearson chi-squared statistic)。


.. math::

    r_i^P = \frac{y_i-\hat{\mu}_i}{\sqrt{\nu(\hat{\mu}_i)}}

分母是方差函数的平方根，缩放将残差置于相似的方差尺度上。
残差的绝对值较大，表明该模型无法满足特定的观察要求。
检测异常值的常见诊断方法是绘制标准化的皮尔逊残差(standardized Pearson residuals)与观察值的关系。




Deviance residuals
==============================================
偏差(deviance)在推导 ``GLM`` 和结果推断中起着关键作用。
偏差残差(deviance residual)是每个观察值相对于总体偏差(overall deviance)的增量。
这些残差很常见，通常是标准化的(standardized)，学生化的(studentized)或两者兼而有之。
偏差残差(deviance residual)是基于卡方分布的，其公式如下。


.. math::

    r_i^D = sign(y_i - \hat{\mu}_i) \sqrt{ \hat{d}_i^2 }


``GLM`` 中不同分布族 :math:`\hat{d}_i^2` 计算法方法不同，表 xxxx 给出了各分布族的计算方法。
通常，在模型检查中，偏差残差（标准化或非标准化残差）优于Pearson残差，
因为其分布特性更接近于线性回归模型中产生的残差。





Score residuals
==============================================
这些是用于计算方差三明治估计的分数。 分数与已优化的分数函数（估计方程）有关。

.. math::
    r_i^S = \frac{y_i-\hat{\mu}_i}{\nu(\hat{\mu}_i) g'(\hat{\mu}_i)}











模型选择(model selection)
##################################################

模型选择(model selection)是指从给定数据的一组候选统计模型中选择出最佳模型的过程。
模型选择是一个既可以应用于不同类型的模型（例如逻辑回归，SVM，KNN等），
又可以应用于配置了不同超参数（例如SVM中的不同内核）的相同类型模型的过程。

在深入探讨不同的模型选择(model selection)方法以及何时使用它们之前，
我们需要弄清楚模型选择(model selection)与模型评估(model evaluation)之间的区别。
模型选择(model selection)关注的是 **模型训练阶段** 的效果，
在给定的数据集下，评价模型的训练误差，即哪个候选模型拟合的更好。
模型评估(model evaluation)旨在评估所选模型的泛化误差(generalization error)，
即所选模型在未知数据上的表现如何。

但是为什么我们需要区分模型选择和模型评估？原因是过度拟合(overfitting)。
一个模型可以在训练阶段表现的非常好，比如饱和模型(saturated model)可完美的拟合每一条训练集样本，
但是其在未知数据上很可能表现的一塌糊涂。
显然，一个好的机器学习模型，
它不仅可以在训练过程中表现出色，而且可以在未知数据上表现出色。
因此，在将模型交付生产之前，我们应该相当确定，当面对新数据时，模型的性能不会降低。


训练一个模型是相对简单的事情，但选择一个"合适"的模型却是一件有挑战的事情。
首先，我们需要克服“最佳”模型的想法。
考虑到数据中的统计噪声，数据样本的不完整以及每种不同模型类型的局限性，
所有模型都具有一定的预测误差。
因此，完美或最佳模型的概念没有用。相反，我们必须寻求一个“足够好”的模型。

选择最终模型时我们关心什么？
不同的应用场景可能会有不同的要求，例如可维护性、有限的模型复杂性、较强的解释性，等等，
有时，具有较低性能但更容易理解的模型可能是优选的。而有时更倾向于效果好的模型，无需关注计算复杂度。
因此，“足够好”的模型可能涉及很多东西，并且特定于您的项目。


通常有三种方法来来选择模型。

- Train, Validation, and Test datasets：利用大量样本集选择模型。
- 概率测度(probabilistic measures)：通过样本误差和复杂度选择模型。
- 重采样方法(resampling methods)：通过估计的样本外误差选择模型。



在理想情况下，我们拥有足够多的数据，
最简单可靠的模型选择方法，将数据分成训练集(training dataset)、验证集(validation dataset)、测试集(test dataset)。
在训练集上拟合候选模型，在验证数据集上进行调整和优化，
最后根据所选度量（例如准确性或误差）指标在测试数据集上选择表现最佳的模型。
这种方法的致命问题是，它需要大量数据。
鉴于我们很少有足够的数据，甚至无法判断什么将是足够的，因此对于大多数预测性建模问题而言，这是不切实际的。
在数据不足的情况下，经常使用后两种方法：概率测度(probabilistic measures)和重采样方法(resampling methods)。




**概率测度(probabilistic measures)**

概率测度(probabilistic measures)依据候选模型在训练数据集上的 **模型表现(model performance)** 和
**模型的复杂性(model complexity)** 对候选模型进行分析评分。
模型复杂性的概念可用于创建有助于模型选择的度量。

众所周知，训练误差偏向乐观，因此不是选择模型的良好基础。
可以根据认为训练错误的乐观程度来惩罚表现。
通常使用特定于算法的方法（通常为线性方法）来实现此目的，
该方法会根据模型的复杂性对分数进行惩罚。
历史上已经提出了各种“信息标准(Information Criterion)”，
试图通过增加惩罚项来补偿最大似然性的偏差，以补偿更复杂模型的过度拟合。

根据奥卡姆剃刀(Occam's razor)的原理，给定具有相似预测或解释能力的候选模型，最简单的模型很可能是最佳选择。
具有较少参数的模型复杂性更低，因此，首选简单模型，因为它平均而言可能会更好地泛化。
四种常用的概率模型选择度量包括：

- 赤池信息准则（Akaike Information Criterion,AIC）。
- 贝叶斯信息准则（Bayesian Information Criterion,BIC）。
- 最小描述长度（Minimum Description Length,MDL）。
- 结构风险最小化（Structural Risk Minimization,SRM）。

当使用更简单的线性模型（例如线性回归或逻辑回归）时，概率度量是适当的，
其中模型复杂度损失的计算（例如样本偏差）是已知的并且易于处理的。



例如 *赤池信息量准则(Akaike information criterion,AIC)* 和
*贝叶斯信息准则(Bayesian information criterion,BIC)*
，两者都会惩罚模型参数的数量，但会奖励训练集的拟合优度，
因此，最佳模型是 ``AIC/BIC`` 最低的模型。
``BIC`` 会更严厉地惩罚模型复杂性，因此 ``BIC`` 倾向于“错误得多”但更简单的模型。
虽然这允许在不使用验证集的情况下进行模型选择，但它只能严格应用于参数线性的模型，即使它通常也适用于更一般的情况，
例如适用于广义线性模型，例如逻辑回归，等等。


**重采样方法(resampling methods)**

重采样方法旨在估计训练样本外数据的模型性能。
这是通过将训练数据集分为子训练集和测试集，
在子训练集上拟合模型并在测试集上对其进行评估来实现的。
然后可以重复此过程多次，并报告每个试验的平均性能。

这是对样本外数据的模型性能进行的蒙特卡洛估计，
尽管每个试验并非严格独立，这取决于所选择的重采样方法，
但是同一数据可能会在不同的训练数据集或测试数据集中多次出现。

三种常见的重采样模型选择方法包括：

- 随机训练/测试分组(Random train/test splits)。
- 交叉验证(Cross-Validation)，k-fold, 留一法(LOOCV)等。
- Bootstrap。

在概率测度(probabilistic measures)不可用的时候，
可以大使用重采样方法。
到目前为止，使用最广的是交叉验证方法系列。



如果你有足够多的训练样本数据，可以直接将数据划分为训练集、验证集和测试集，选择合适的模型。
数据量少的时候也可以使用重采样法解决。
这两种方法简单直接，没有什么可细说的，
本节我们详细介绍几种常用的概率测度方法。
首先，我们定义一些符号

.. math::

    &p = \text{模型的参数数量}

    &N = \text{观测样本的数量}

    &L= \text{模型的似然}

    &\ell= \text{模型的对数似然}

    &D= \text{模型的偏差 deviance}

    &G^2 = \text{模型的似然比检验}


接下来，我们详细介绍一下用于模型比较的 ``AIC`` 和 ``BIC`` 量度的公式，
这些度量指标试图找到在模型拟合优度和模型复杂度之间的平衡点。



AIC
=======================================

赤池信息准则(Akaike information criterion,AIC）是样本外预测误差的估计值，度量的是在给定数据集下统计模型的相对质量。
在给定数据集的候选模型集合中，
``AIC`` 估计每个模型相对于其他模型的质量。因此，``AIC`` 提供了一种模型选择的方法。

``AIC`` 建立在信息论(information theory)的基础上。
当使用统计模型来表征数据的生成过程时，几乎永远不会是精确的，
统计模型一定会丢失一些信息。
``AIC`` 估计模型丢失的相对信息量：模型丢失的信息越少，该模型的质量越高。
在估算模型丢失的信息量时，``AIC`` 会在模型拟合优度(goodness of fit)和模型复杂性之间进行权衡。
换句话说，``AIC`` 同时处理过度拟合和欠拟合的风险。
``Akaike information criterion`` 是由制定该标准的统计学家 ``Hirotugu Akaike`` 命名的。
现在，它构成了统计基础范例的基础，并且广泛用于统计推断(statistical inference)。


``AIC`` 可用于比较嵌套模型或非嵌套模型。
信息准则是对目标模型丢失的信息的度量，目的是找到信息丢失最少的模型。


.. math::

    AIC= 2p-2 \ell


:math:`\ell(M_k)` 代表了模型拟合能力，:math:`p` 代表了模型的复杂程度。
注意，``AIC`` 的绝对值是没有意义的，模型之间的相对大小才有意义。
当比较的两个模型拟合能力(似然)相差较大时，``AIC`` 受到似然值的影响更大一些；
当两个模型拟合能力(似然)相当时，``AIC`` 受到模型参数数量 :math:`p` 的影响更大一些。


参数数量 :math:`p` 的项是对较大的参数变量列表的一种惩罚，
``AIC`` 特别适合比较具有相同链接和方差函数但具有不同参数变量列表的 ``GLM``。
当模型嵌套时，我们将惩罚项视为从模型中消除候选预测变量所需的精度。

我们需要注意如何计算 ``AIC``，上面的定义包括模型对数似然。
在 ``GLM`` 中，参数估计过程通常不是基于似然的，而是基于偏差(deviance)的，
不能使用偏差值去算 ``AIC`` 的值，
因为偏差的计算过程中不包括归一化项 :math:`c(y_i,\phi)`
，而在 ``GLM`` 中不同的分布拥有不同的归一化项。


后来又衍生出了以几种 ``AIC`` 的变种版本，这里给出两种替代方法。
第一种是 ``Sugiura（1978）`` 和 ``Hurvich and Tsai（1989）`` 提出的校正或有限样本(finite-sample)AIC。
第二个是 ``Hannan and Quinn（1979）`` 描述的 ``AIChq``。
这些版本的公式(未缩放)为：

.. math::

        AICc &= 2\frac{p(p+1)}{N-p-1}+ 2p -2 \ell

        AIChq &= 2p\ln\{ \ln(N)\} -2 \ell


我们如何确定两个 ``AIC`` 统计数据之间的差异是否足够大，足以使我们得出结论，一个模型比另一个模型更合适？
特别是，具有较低 ``AIC`` 统计量的模型是否比其他模型更受青睐？
尽管我们知道具有较小 ``AIC`` 的模型是更可取的，但尚无可用于计算p-值的特定统计检验。
``Hilbe（2009）`` 根据模拟研究设计了一个主观表，可用于做出比较无标度 ``AIC`` 度量的决策。

.. _fg_me_saturated_0014:

.. figure:: pictures/me_saturated_0014.jpg
    :scale: 40 %
    :align: center




BIC
=======================================



在统计中，贝叶斯信息准则（BIC）或Schwarz信息准则（也称为SIC，SBC，SBIC）
是用于在有限的一组模型中选择模型的标准，``BIC`` 最低的模型是首选。
它部分基于似然函数，并且与 ``AIC`` 密切相关。

.. math::

    BIC_{\ell} = p\ln(N) - 2 \ell

与 ``AIC`` 相反，``BIC`` 包含的惩罚项随着样本数量的增加而变得更加严格。，
该特征反映了可用于检测重要性的能力。
``Raftery (1995)`` 提出了一个基于偏差版本的 ``BIC``，
``Raftery`` 的目的是使用替代版本的 ``BIC`` 在 ``GLM`` 模型之间进行选择。

.. math::

    BIC_D = D - p \ln(N)


当比较非嵌套模型时，可以根据两个模型的 ``BIC`` 统计数据之间的差的绝对值来评估模型的偏好程度。
``Raftery（1995）`` 给出的用于确定相对偏好的量表。



.. _fg_me_saturated_0015:

.. figure:: pictures/me_saturated_0015.jpg
    :scale: 40 %
    :align: center



